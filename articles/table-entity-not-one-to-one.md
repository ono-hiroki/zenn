---
title: "テーブルとEntityは1対1じゃなくてもいい"
emoji: "🧩"
type: "tech"
topics: ["architecture", "oop", "solid"]
published: true
---

## はじめに

「1テーブル = 1Entity」という設計パターンは広く使われています。ORMの自動生成機能もこの前提で作られていることが多いでしょう。

しかし、この対応関係は必須というわけではありません。

- 同じテーブルを参照するEntityが複数あってもいい
- 複数のテーブルを1つのEntityにまとめてもいい

この記事では、基本的なソフトウェア設計原則から、なぜそう言えるのかを解説します。

:::message
この記事での「Entity」は、データと振る舞いをまとめたクラスを指します。特定のフレームワークや設計手法に限定しません。
:::

## テーブル中心設計の問題

「テーブルがあるからEntityを作る」という発想で設計すると、以下の問題が起きがちです。

### 問題1：Entityの肥大化

`users`テーブルに対応する`User`Entityを考えます。このテーブルには認証情報、プロフィール、権限、設定など様々なカラムがあります。

1つのEntityで全てを扱おうとすると：
- プロパティが数十個に膨れ上がる
- メソッドも用途ごとに増え続ける
- ファイルが数百〜数千行になる

### 問題2：無関係な要素の混在

認証処理を書くとき、プロフィール情報は不要です。プロフィール更新を書くとき、パスワードハッシュは不要です。

しかし1つのEntityに全てがあると：
- 認証のテストでもプロフィールのセットアップが必要
- プロフィールの変更が認証コードに影響する可能性
- コードを読む人の認知負荷が増大

### 問題3：変更の影響範囲が不明確

巨大なEntityを変更するとき、「この変更は他のどこに影響するか？」の判断が難しくなります。認証ロジックを修正したつもりが、プロフィール表示に影響を与えてしまう—そんな事故が起きやすくなります。

## 設計原則から考える

これらの問題は、基本的な設計原則に照らすと明確に説明できます。

### 単一責任の原則（SRP）・関心の分離

> クラスを変更する理由は1つであるべき

`User`Entityが変更される理由を列挙すると：
- 認証ロジックの変更（パスワードポリシー変更など）
- プロフィール項目の追加・変更
- 権限モデルの見直し
- 通知設定の変更

「認証できるか？」と「名前は何か？」は異なる関心事であり、仕様変更も通常は別々に起こります。これらを同じEntityに混在させると、一方の変更が他方に影響するリスクが生まれます。

変更理由が複数あるなら、Entityを分割する候補です。

### 凝集度（Cohesion）

> 関連性の高い要素を集め、関連性の低い要素は分離する

高い凝集度を持つEntityは：
- プロパティ同士が密接に関連している
- メソッドが多くのプロパティを使う
- 1つの目的のために存在している

`passwordHash`と`failedLoginAttempts`は密接に関連しています（認証の文脈）。
`name`と`email`も密接に関連しています（プロフィールの文脈）。

一方、`passwordHash`と`name`の関連性は低いです。これらを同じEntityに入れると、凝集度が下がります。

### インターフェース分離の原則（ISP）

> クライアントは自分が使わないメソッドに依存すべきでない

認証処理は`authenticate()`と`recordFailedAttempt()`だけを必要とします。`updateProfile()`や`changeSettings()`は不要です。

巨大な`User`Entityに依存すると、不要なメソッドへの依存が生まれます。用途別にEntityを分ければ、必要なインターフェースだけに依存できます。

## 分割の判断基準

では、いつ分割し、いつ統合すべきでしょうか？

### 統合すべきケース：プロパティ間に守るべきルールがある

複数のプロパティが連動してビジネスルールを構成する場合、それらは同じEntityに属するべきです。

```
例：銀行口座
「残高 + 与信枠 >= 0」というルールがある
→ 残高と与信枠は同じEntityで管理すべき
  （分割すると、このルールを保証できなくなる）
```

### 統合すべきケース：ライフサイクルが同じ

同時に作成・削除されるデータは、同じEntityで管理する方が自然です。

これは異なるテーブルでも同様です。ライフサイクルが同じなら、複数テーブルのデータを1つのEntityにまとめることも有効な選択肢です。

```
例：注文と注文明細（異なるテーブル）
- ordersテーブル と order_linesテーブル
- 注文が作成されたら明細も作成される
- 注文が削除されたら明細も削除される
→ Order Entityが両テーブルのデータを持つのが自然
```

テーブル構造は正規化の都合で分かれていても、ビジネス上は「注文」という1つの概念です。Entityはこのビジネス上の概念を反映すべきです。

### 分割を検討するケース：利用場面・変更理由が異なる

同じテーブルでも、使われる場面や変更される理由が異なるなら、分割を検討します。

- 認証処理では「ログインID、パスワード、ロック状態」
- プロフィール表示では「名前、メール、アイコン」
- 権限チェックでは「ロール、権限リスト」

これらは独立して変更されます。認証ポリシーの変更とプロフィール項目の追加は、別々のタイミングで起こるのが普通です。

それぞれの場面で必要なプロパティだけを持つEntityを作れば、変更の影響範囲が明確になり、シンプルで扱いやすくなります。

## 実践的なアプローチ

### 利用場面ごとにEntityを設計する

```
認証の場面:
  AuthenticatableUser
  - loginId
  - passwordHash
  - failedAttempts
  - lockedAt

プロフィールの場面:
  UserProfile
  - name
  - email
  - phoneNumber

権限の場面:
  UserPermissions
  - roles
  - permissions
```

これらは全て同じ`users`テーブルを参照しますが、それぞれが単一の責任を持つ小さなEntityです。

### 更新対象を明確にする

各Entityは自分の責務に関するカラムのみを更新します。

- `AuthenticatableUser`は認証関連のカラムだけ
- `UserProfile`はプロフィール関連のカラムだけ

更新対象が重複しなければ、競合は発生しません。

### 複数の機能にまたがるルールへの対応

「ロック中のユーザーはプロフィール変更不可」のような、機能をまたぐルールがある場合：

```
プロフィール更新処理:
1. 認証Entityからロック状態を確認
2. ロック中なら処理を中断
3. プロフィールEntityで更新を実行
```

Entity自体は単一の責任を保ちながら、上位の層（サービス層など）で複数のEntityを協調させます。

## まとめ

| 原則 | 1つのEntityに統合 | 複数Entityに分割 |
|------|-----------------|-----------------|
| 単一責任（SRP） | 変更理由が1つなら | 変更理由が複数なら |
| 凝集度 | プロパティ間の関連が高いなら | 関連が低いなら |
| ビジネスルール | プロパティ間に守るべきルールがあるなら | 独立して変更可能なら |
| ライフサイクル | 同時に作成・削除されるなら（テーブルが別でも） | 独立して存在するなら |
| 利用場面 | 常に一緒に使うなら | 場面ごとに異なるなら |

Entityはテーブルの写像ではなく、特定の場面における責務の表現です。

テーブル構造に引きずられず、設計原則に従って統合・分割を判断する。それが長期的にメンテナンスしやすいコードにつながります。

## 参考文献

- Robert C. Martin『Clean Architecture』
- Robert C. Martin『Agile Software Development』（SOLID原則）
